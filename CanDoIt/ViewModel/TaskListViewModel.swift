//
//  TaskListViewModel.swift
//  CanDoIt
//
//  Created by Роман Предеин on 09.02.2022.
//

import SwiftUI
import CoreData

class TaskListViewModel: ObservableObject {
    
    // The Task class is automatically generated by CoreData when we create an entity (check DataModel inspector by Entity (Task) - Class - CodeGen. We using "Class Definition" option).
    // We will use an alias EntityModel only for better understanding
    typealias EntityModel = Task
    
    // For the first run, the task list will be empty
    // Than we need to track changes with @Published property wrapper
    @Published var tasks: [EntityModel] = []
    
    // Create managed local storage
    private let persistenceController = PersistenceController()

    
    // MARK: - Loading data
    func loadData() {
        
        // Request objects that match our model
        let request = NSFetchRequest<EntityModel>(entityName: K.entityName)
        
        // SORT RULES:
        // Priority or basic sort mean sort by a special attribute in CoreData Item.
        // That allow us to save changes in order by user.
        let sort = NSSortDescriptor(key: K.basicSortingKey, ascending: true)
        let fallbackSort = NSSortDescriptor(key: K.fallbackSortingKey, ascending: false)
        
        // Applying sorting
        request.sortDescriptors = [sort, fallbackSort]
        
        do {
            // Try to load the result into the monitored array
            try tasks = persistenceController.container.viewContext.fetch(request)
        } catch {
            // If it doesn't work
            print("Error getting data. \(error.localizedDescription)")
        }
    }
    
    // MARK: - Saving data
    func saveData() {
        
        // Only if changes are detected
        if persistenceController.container.viewContext.hasChanges {
            do {
                // Try to save all data in the currrent container
                try persistenceController.container.viewContext.save()
                
                // And load it again to update the published variable to reflect this change
                loadData()
            } catch let error {
                // If it doesn't work
                print("Error: \(error)")
            }
        }
    }

    // MARK: - New data
    func addNewItem(with title: String) {
        
        // Initializing the creation of a new entity
        let newItem = EntityModel(context: persistenceController.container.viewContext)
        
        // Then assign values to all properties
        newItem.id = UUID()
        newItem.isDone = false
        newItem.title = title
        newItem.timestamp = Date()
        newItem.order = 0 // By default is zero unless an user wants to change the sort.
        
        // And start saving
        saveData()
    }
    
    // MARK: - Remove data
    func deleteItems(by offsets: IndexSet) {
        // The IndexSet contains all passed items
        // Most of the time it's just one item, but theoretically, we can work with bulk items.
        
        // Select all matches and start the removal cycle
        offsets.map { tasks[$0] }.forEach(persistenceController.container.viewContext.delete)
        
        // And start saving certainly
        saveData()
    }
    
    // MARK: - Reorder data items
    func move(from source: IndexSet, to destination: Int) {
        // Just like in deleteItems func we have the IndexSet contains all passed items.
        // And destination with number of row in the List.
         
        // Change the order of the items in the array is really simple
        tasks.move(fromOffsets: source, toOffset: destination )

        // Then, to save the new order in CoreData we can by update a special attribute for all of Items
        // We simply take the number of all entries (remember that the first element is numbered zero, so we subtract one from the total) and assign the value in order, subtracting one each time until we reach position zero.
        for reverseIndex in stride( from: tasks.count - 1, through: 0, by: -1 ) {
           tasks[ reverseIndex ].order = Int16( reverseIndex )
        }
        
        saveData()
    }

    
}
